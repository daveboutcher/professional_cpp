---
layout: post
title:  "Exercise 5 - Move/Copy/Assign and Containers"
---

<div class="box" markdown="1">
Exercise 5 Objective
: Put our textures in a container and implement proper *move* functions
</div>

Our `cdl` objects that wrap `SDL` pointers all have the same
behaviour.  The objects should not be *copied*, but it is valid to
*move* the SDL pointer from one `cdl` object to another.

![surface copy](  {{ "/assets/copy_surface.svg" | absolute_url }} )

If we use the default C++ copy operation, when we copy one
`cdl::Surface` to another it just copies the contents of all of the
member variables...so we end up with two `cdl::Surface` pointing to
the same `SDLSurface`.  When their destructors are called, we end up
calling `SDL_FreeSurface` twice for the same `SDLSurface`, and   
Bad Things&trade; happen.

The same thing will happen if we pass a `cdl::Surface` by *value*.
For example, if the constructor for the `cdl::Texture` object is
~~~ C++
Texture(SDL_Renderer *sdl_renderer, Surface surface) {
... 
}
~~~
where the surface is passed by value, C++ will make a **copy** of the
surface, using the default copy constructor and we will have the
problem described above.  One solution in the first exercise is to
pass surface by *reference*.
~~~ C++
Texture(SDL_Renderer *sdl_renderer, const Surface &surface) {
... 
}
~~~
and further, to *prevent* copying by deleting the copy constructor.  
~~~ C++
Surface(const Surface &other) = delete;
~~~

Most of the time when you pass by reference, you want the *behavior*
of passing by value (i.e. the data is an input parameter to the
method) without the overhead and side-effects of copying an object.
It is strongly recommended to get in the habit of passing data by
const reference, as is done above, unless the data will actually be
modified ([P.10: Prefer immutable data to mutable
data](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#p10-prefer-immutable-data-to-mutable-data),
[Con.3: By default, pass pointers and references to
consts](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#con3-by-default-pass-pointers-and-references-to-consts).) 

Before [C++11](https://en.wikipedia.org/wiki/C%2B%2B11), there was a
rule called the *Rule of Three* that states "If a class defines one
(or more) of the following it should probably explicitly define all
three:
* destructor
* copy constructor
* copy assignment operator"

Our fundamenatal problem was that we violated this rule....we created
a destructor, but did not create the other two.  Even with the code in
the solution to Exercise 2 we still violate the Rule of 3, so it would
be safest to also add:
~~~ C++
Surface & operator= (const Surface & other) = delete;
~~~
which prevents **assigning** one Surface to another, and once again
ending up with two `cdl::Surface` objects pointing to the same.

As a short exercise, make sure your `cdl::Surface` class has deleted
those operations, and then try adding your `cdl::Surface` objects to a
vector.  Update your main temporarily to do:
~~~ C++
// At the top
#include <vector>

...

// After creating a surface object, try adding it to a vector
std::vector<cdl::Surface> v;
v.push_back(club_surface);
~~~
You should get the standard set of horrendous C++ errors.  Mine look
as follows:
~~~
In file included from /usr/include/x86_64-linux-gnu/c++/7/bits/c++allocator.h:33:0,
                 from /usr/include/c++/7/bits/allocator.h:46,
                 from /usr/include/c++/7/vector:61,
                 from cards.cpp:8:
/usr/include/c++/7/ext/new_allocator.h: In instantiation of ‘void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = cdl::Surface; _Args = {const cdl::Surface&}; _Tp = cdl::Surface]’:
/usr/include/c++/7/bits/alloc_traits.h:475:4:   required from ‘static void std::allocator_traits<std::allocator<_Tp1> >::construct(std::allocator_traits<std::allocator<_Tp1> >::allocator_type&, _Up*, _Args&& ...) [with _Up = cdl::Surface; _Args = {const cdl::Surface&}; _Tp = cdl::Surface; std::allocator_traits<std::allocator<_Tp1> >::allocator_type = std::allocator<cdl::Surface>]’
/usr/include/c++/7/bits/stl_vector.h:943:30:   required from ‘void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = cdl::Surface; _Alloc = std::allocator<cdl::Surface>; std::vector<_Tp, _Alloc>::value_type = cdl::Surface]’
cards.cpp:43:27:   required from here
/usr/include/c++/7/ext/new_allocator.h:136:4: error: use of deleted function ‘cdl::Surface::Surface(const cdl::Surface&)’
  { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from cdl/texture.h:5:0,
                 from cdl/cdl.h:5,
                 from cards.cpp:10:
cdl/surface.h:23:2: note: declared here
  Surface(const Surface &other) = delete;
  ^~~~~~~
In file included from /usr/include/c++/7/vector:62:0,
                 from cards.cpp:8:
/usr/include/c++/7/bits/stl_construct.h: In instantiation of ‘void std::_Construct(_T1*, _Args&& ...) [with _T1 = cdl::Surface; _Args = {cdl::Surface}]’:
/usr/include/c++/7/bits/stl_uninitialized.h:83:18:   required from ‘static _ForwardIterator std::__uninitialized_copy<_TrivialValueTypes>::__uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = std::move_iterator<cdl::Surface*>; _ForwardIterator = cdl::Surface*; bool _TrivialValueTypes = false]’
/usr/include/c++/7/bits/stl_uninitialized.h:134:15:   required from ‘_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = std::move_iterator<cdl::Surface*>; _ForwardIterator = cdl::Surface*]’
/usr/include/c++/7/bits/stl_uninitialized.h:289:37:   required from ‘_ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, std::allocator<_Tp>&) [with _InputIterator = std::move_iterator<cdl::Surface*>; _ForwardIterator = cdl::Surface*; _Tp = cdl::Surface]’
/usr/include/c++/7/bits/stl_uninitialized.h:311:2:   required from ‘_ForwardIterator std::__uninitialized_move_if_noexcept_a(_InputIterator, _InputIterator, _ForwardIterator, _Allocator&) [with _InputIterator = cdl::Surface*; _ForwardIterator = cdl::Surface*; _Allocator = std::allocator<cdl::Surface>]’
/usr/include/c++/7/bits/vector.tcc:426:6:   required from ‘void std::vector<_Tp, _Alloc>::_M_realloc_insert(std::vector<_Tp, _Alloc>::iterator, _Args&& ...) [with _Args = {const cdl::Surface&}; _Tp = cdl::Surface; _Alloc = std::allocator<cdl::Surface>; std::vector<_Tp, _Alloc>::iterator = __gnu_cxx::__normal_iterator<cdl::Surface*, std::vector<cdl::Surface> >; typename std::_Vector_base<_Tp, _Alloc>::pointer = cdl::Surface*]’
/usr/include/c++/7/bits/stl_vector.h:948:21:   required from ‘void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = cdl::Surface; _Alloc = std::allocator<cdl::Surface>; std::vector<_Tp, _Alloc>::value_type = cdl::Surface]’
cards.cpp:43:27:   required from here
/usr/include/c++/7/bits/stl_construct.h:75:7: error: use of deleted function ‘cdl::Surface::Surface(const cdl::Surface&)’
     { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from cdl/texture.h:5:0,
                 from cdl/cdl.h:5,
                 from cards.cpp:10:
cdl/surface.h:23:2: note: declared here
  Surface(const Surface &other) = delete;
  ^~~~~~~
~~~

The critical message is "error: use of deleted function
‘cdl::Surface::Surface(const cdl::Surface&)’".  To put the surface
object into the vector, C++ wants to make a copy of the object, which
we have (correctly) prevented.  Which leads us to the next section...

## Moving Objects

C++11 added the ability to *move* one object to another.  This is
fundamentally different than the operations we deleted above...it is
totally legitimate to move an `SDLSurface` to another.  What was added
is C++ *move semantics*.  

In our case, the next thing we want to do is *move* our `cdl::Surface`
into a container like the vector....keep a `std::vector` of
`cdl::Surface` objects. 
To do that we need consider the *Rule of Five* (introduced with C++11)
that now says adds the following two operators:
~~~ c++
// Move Constructor
Surface (Surface&& other) {
    surface_ = other.surface_;
    other.surface_ = nullptr;
}

// Move assignment operator
Surface& operator= (Surface&& other) {
    surface_ = other.surface_;
    other.surface_ = nullptr;
    return *this;			   
}
~~~

The C++ Core Guidelines say [C.21: If you define or =delete any
default operation, define or =delete them
all](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c21-if-you-define-or-delete-any-default-operation-define-or-delete-them-all). 

Those two operations **move** the `surface_` pointer from one object
to another and, very importantly, set it to `nullptr` in the
moved-from object.  There are lots of reasons to use (or require) move
semantics.  Sometimes for functional reasons, like our SDL wrappers,
and sometimes for performance reasons.  Move semantics are often not
taught in colleges, and are one of the concepts it is important to
understand (and will help impress an interviewer for a C++ job.)

The SDL documentation for SDL_FreeSurface states "It is
safe to pass NULL to this function", so we don't have to do anything
special in our destructor.

Add those two operations to the `cdl::Surface` class and try compiling
the code that adds the surface to a vector again.  **We should see
the same error as before!**  To make this work, we have to tell C++
that its OK to move the data out of the first object.   Change the
code to be as follows:
~~~ c++
std::vector<cdl::Surface> v;
v.push_back(std::move(club_surface));
~~~

By default C++ won't move the data out of an object unless we say its
OK.  There is a lot of confusion, even among experienced C++
programmers, about what `std::move` does.  The simplest way to think
about it is that it gives *permission* to move something....it does
**not** (despite its name) actually move anything.  I often think it
should have been called `std::movable`.

The discussion of move semantics can get complicated, with lots of
discussions about `lvalues` and `rvalues`.  Scott Meyers [Effective Modern
C++](https://www.amazon.com/dp/1491903996/) has a whole chapter
("Rvalue References, Move Semantics, and Perfect Forwarding) that
starts by saying "When you first learn about them, move semantics and
perfect forwarding seem pretty straightforward."  When someone starts
aa sentence like that, you can be sure there is a "but..." to follow,
and indeed there is.  At some point it is definitely worth reading and
understanding that chaper.

By the way, we have the very simple structs in our example such as 
~~~ c++
struct size {
    int width;
    int height;
};
~~~
This is the kind of class where the default behavior is fine...it
doesn't violate any rules, and we don't need to define any special
constructors. Again, from the Core Guidelines, [C.20: If you can avoid
defining default operations,
do](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c20-if-you-can-avoid-defining-default-operations-do). 

## Exercise 5

We are going to make our code much more programatic and less repeaty.
Once again the Exercise3-start branch contains the following cards.cpp
file.  The cdl/* files are from the end of Exercise 3, and this this
will NOT compile.  The goal is to make it compile by updating the cdl
classes.  
~~~ C++
/***********************************************************************
 * Card Game Example - part of the Professional C++ tutorial
 ***********************************************************************
 * This work is licensed under a Creative Commons Attribution 4.0 
 * International License. Details at 
 * http://creativecommons.org/licenses/by/4.0/
 ***********************************************************************/
#include <vector>
#include <iostream>
#include "cdl/cdl.h" // includes the "running()" method
#include "cdl/window.h"
#include "cdl/surface.h"
#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>

int main(int argc, char *argv[])
{
    // Initialize SDL
    SDL_Init(SDL_INIT_VIDEO);

	try {

		cdl::Window window = cdl::Window("Cards",
										 cdl::position{SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED},
										 cdl::size{480, 480});

		cdl::Renderer renderer = window.createRenderer();

		std::vector<cdl::Texture> cards;

		for (const auto &filename: std::initializer_list<const char *>{"club.png",
  				                                                       "diamond.png",
					                                                   "heart.png",
					                                                   "spade.png"}) {
			cdl::Surface card_surf = cdl::Surface(filename);
			cdl::Texture card_text = renderer.createTexture(card_surf);
			cards.push_back(std::move(card_text));
		}
		
		// This is the main SDL loop
		while(cdl::running()) {

			renderer.clear();

			// Add the row of textures at Y position 10
			renderer.addRow(cards, 10);

			renderer.display();
		}
	} catch (const cdl::exception &e) {
		std::cerr << e.what() << std::endl;
	}

    SDL_Quit();
    return 0;
}
~~~

1. Add the card textures to a vector (that should already be done.)
1. Create and `addRow()` method on the Renderer class that adds a row
of textures.  All the logic from the previous exercise for calculating
padding and positions should move into the renderer class.
1. Make sure all your cdl classes follow the "rule of 5" where appropriate





